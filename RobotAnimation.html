<html>
<style type="text/css">
  canvas { background: red; }
</style>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec4 vPos;

void main()
{
  gl_PointSize = 1.0;
  gl_Position = vPos;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 u_color;

void main()
{
   gl_FragColor = u_color;
}
</script>


<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="initshaders.js"></script>
<script type="text/javascript" src="T7lines.js"></script>
<script type="text/javascript" src="T7matrices.js"></script>

<script>
window.addEventListener("keydown", keycheck, false);

function keycheck(e) {
  // Toggle pause/unpause when the letter p is pressed
  if (e.keyCode == "80") {
    paused = !paused;
  }

  // Toggle solid/opaque when the letter s is pressed
  if (e.keyCode == "83") {
    solid = !solid;
  }
}

</script>

<script type="text/javascript">
var canvas;
var gl;
var colorUniformLocation;

var offset = 0;
var degrees = 0;

var paused = false;
var solid = true;
var useParallelProjection = true;

// 3D World coordinate points
/*Represents the robot's torso, head and face. The animation should have these parts move the same as the robot bends over*/
//TODO: Can I just multiply part of a matrix? Since it would be best to put all of this in one matrix, but we need things to move separately.
//I'm sure there is. Like we can do originalPoints[0-7] or something. Or we could start at a certain spot since we know where everything's at.
var originalPoints = [  //Points for a cube that represents the robot's head
                        //Each cube should follow this same order, just to keep things simple.
                        [-150.0, -150.0, 250.0, 1.0], //bottom left, furthest away
                        [150.0, -150.0, 250.0, 1.0], //Bottom right, furthest away
                        [-150.0, 150.0, 250.0, 1.0], //Top left, furthest away
                        [150.0, 150.0, 250.0, 1.0], //Top right, furthest away
                        [-150.0, -150.0, -50.0, 1.0], //Bottom left closest
                        [150.0, -150.0, -50.0, 1.0], //Bottom right closest
                        [-150.0, 150.0, -50.0, 1.0], //Top left closest
                        [150.0, 150.0, -50.0, 1.0], //Top right closest

                        //Points for a rectangular prism that represents the robot's torso
                        [-100.0, -350.0, 200.0, 1.0],
                        [100.0, -350.0, 200.0, 1.0],
                        [-100.0, -150.0, 200.0, 1.0],
                        [100.0, -150.0, 200.0, 1.0],
                        [-100.0, -350.0, -25.0, 1.0],
                        [100.0, -350.0, -25.0, 1.0],
                        [-100.0,-150.0, -25.0, 1.0],
                        [100.0, -150.0, -25.0, 1.0],

                        //Points for a prism that represents the robot's mouth
                      /*Copy pasted from head; Maybe we don't need the back face since it'll never be drawn *shrugs*
                      TODO: Work this out bc... Huh? Maybe we do need all of these points. Otherwise, things get confusing.
                      We can still divide these into their own matrices since each of these will do different things in the animation
                      */
                     
                      [-50.0, -100.0, -50.0, 1.0],
                      [50.0, -100.0, -50.0, 1.0],
                      [-50.0, -50.0, -50.0, 1.0], 
                      [50.0, -50.0, -50.0, 1.0],
                      [-50.0, -100.0, -51.0, 1.0],
                      [50.0, -100.0, -51.0, 1.0],
                      [-50.0, -50.0, -51.0, 1.0],
                      [50.0, -50.0, -51.0, 1.0],
                      //Points for a prism that represents the robot's left eye
                      [-50.0, -0.0, -50.0, 1.0],
                      [0.0, -0.0, -50.0, 1.0],
                      [-50.0, 50.0, -50.0, 1.0], 
                      [0.0, 50.0, -50.0, 1.0],
                      [-50.0, 0.0, -51.0, 1.0],
                      [0.0, 0.0, -51.0, 1.0],
                      [-50.0, 50.0, -51.0, 1.0],
                      [0.0, 50.0, -51.0, 1.0],

                      //Points for a prism that represents the robot's right eye
                      [75.0, 0.0, -50.0, 1.0],
                      [25.0, 0.0, -50.0, 1.0],
                      [75.0, 50.0, -50.0, 1.0], 
                      [25.0, 50.0, -50.0, 1.0],
                      [75.0, 0.0, -51.0, 1.0],
                      [25.0, 0.0, -51.0, 1.0],
                      [75.0, 50.0, -51.0, 1.0],
                      [25.0, 50.0, -51.0, 1.0],

                        //Points for a rectangular prism that represents the robot's left arm
                        [-200.0, -350.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [-200.0, -150.0, 150.0, 1.0],
                        [-100.0, -150.0, 150.0, 1.0],
                        [-200.0, -350.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [-200.0, -150.0, 25.0, 1.0],
                        [-100.0, -150.0, 25.0, 1.0],  

                        //Points for a rectangular prism that represents the robot's right arm
                        [100.0, -350.0, 150.0, 1.0],
                        [200.0, -350.0, 150.0, 1.0],
                        [100.0, -150.0, 150.0, 1.0],
                        [200.0, -150.0, 150.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0],
                        [200.0, -350.0, 25.0, 1.0],
                        [100.0, -150.0, 25.0, 1.0],
                        [200.0, -150.0, 25.0, 1.0], 

                        //Points for a rectangular prism that represents the robot's left leg
                        [-100.0, -500.0, 150.0, 1.0],
                        [0.0, -500.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [-100.0, -500.0, 25.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0],

                        //Points for a rectangular prism that represents the robot's left leg
                        [0.0, -500.0, 150.0, 1.0],
                        [100.0, -500.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [100.0, -350.0, 150.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [100.0, -500.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0],

                        //Points for a cube that represents the box the robot will pick up
                        [-100.0, -500.0, -50.0, 1.0],
                        [100.0, -500.0, -50.0, 1.0],
                        [-100.0, -350.0, -50.0, 1.0],
                        [100.0, -350.0, -50.0, 1.0],
                        [-100.0, -500.0, -150.0, 1.0],
                        [100.0, -500.0, -150.0, 1.0],
                        [-100.0,-350.0, -150.0, 1.0],
                        [100.0, -350.0, -150.0, 1.0],
                      
                      
                      ];

//We just need the one faces vector since we're only doing cubes
var faces = [ //0-7
            [0, 1, 3, 2],
            [5, 4, 6, 7],
            [4, 0, 2, 6],
            [1, 5, 7, 3],
            [2, 3, 7, 6],
            [1, 0, 4, 5],

            //8-15
            [8, 9, 11, 10],
            [13, 12, 14, 15],
            [12, 8, 10, 14],
            [9, 13, 15, 11],
            [10, 11, 15, 14],
            [9, 8, 12, 13],

            //16-23
            [16, 17, 19, 18],
            [21, 20, 22, 23],
            [20, 16, 18, 22],
            [17, 21, 23, 19],
            [18, 19, 23, 22],
            [17, 16, 20, 21],

            //24-31
            [24, 25, 27, 26],
            [29, 28, 30, 31],
            [28, 24, 26, 30],
            [25, 29, 31, 27],
            [26, 27, 31, 30],
            [25, 24, 28, 29],

            //32-39
            [32, 33, 35, 34],
            [37, 36, 38, 39],
            [36, 32, 34, 38],
            [33, 37, 39, 35],
            [34, 35, 39, 38],
            [33, 32, 36, 37],

            //40-47
            [40, 41, 43, 42],
            [45, 44, 46, 47],
            [44, 40, 42, 46],
            [41, 45, 47, 43],
            [42, 43, 47, 46],
            [41, 40, 44, 45],

            //48-55
            [48, 49, 51, 50],
            [53, 52, 54, 55],
            [52, 48, 50, 54],
            [49, 53, 55, 51],
            [50, 51, 55, 54],
            [49, 48, 52, 53],  
            
            //56-63
            [60, 57, 59, 58],
            [61, 60, 62, 63],
            [60, 56, 58, 62],
            [57, 61, 63, 59],
            [58, 59, 63, 62],
            [57, 56, 60, 61],
          
            //64-71
            [64, 65, 67, 66],
            [69, 68, 70, 71],
            [68, 64, 66, 70],
            [65, 69, 71, 67],
            [66, 67, 71, 70],
            [65, 64, 68, 69],
            //72-79
            [72, 73, 75, 74],
            [77, 76, 78, 79],
            [76, 72, 74, 78],
            [73, 77, 79, 75],
            [74, 75, 79, 78],
            [73, 72, 76, 77]];

var zBufferDepth = [];
var zBufferColor = [];

window.onload = init;

/*
  Code for the 360 rotation
   if (!paused)
   {
     offset+=2;
     degrees+=2;
   }
   if (offset > 500)
   {
     offset = 0;
   }
   if (degrees > 360)
   {
     degrees = 0;
   }
   var radians = degrees * (Math.PI / 180.0);
   */

     //TODO: Add all other vectors to vertices. Remember, they're all separate due to the animations.
   
   
   //Once Vertices is populated with the actual lines, we can use triangle fan to draw using the points we have. We don't
   //have to worry about fill algorithms.
   function render() {

   if (!paused)
   {
     offset+=2;
     degrees+=2;
   }
   if (offset > 500)
   {
     offset = 0;
   }
   if (degrees > 360)
   {
     degrees = 0;
   }
   var radians = degrees * (Math.PI / 180.0);
  

   // Determine transformations
   var Midentity = [ [1, 0, 0, 0],
                     [0, 1, 0, 0],
                     [0, 0, 1, 0],
                     [0, 0, 0, 1] ];
   var Mtranslate = [ [1, 0, 0, 0],
                      [0, 1, 0, 2.0*offset],
                      [0, 0, 1, -2.0*offset],
                      [0, 0, 0, 1]  ];
   var MrotationZ = [ [Math.cos(radians), -1.0*Math.sin(radians), 0, 0],
                      [Math.sin(radians), Math.cos(radians), 0, 0],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1]  ];
   var MrotationY = [ [Math.cos(radians), 0, Math.sin(radians), 0],
                      [0, 1, 0, 0], 
                      [-1.0*Math.sin(radians), 0, Math.cos(radians), 0],
                      [0, 0, 0, 1]  ];
   var MrotationX = [ [1, 0, 0, 0],
                      [0, Math.cos(radians), -1.0*Math.sin(radians), 0],
                      [0, Math.sin(radians), Math.cos(radians), 0],
                      [0, 0, 0, 1]  ];
   var Mscaling = [ [offset/100.0, 0, 0, 0],
                    [0, offset/100.0, 0, 0],
                    [0, 0, offset/100.0, 0],
                    [0, 0, 0, 1] ];

    var t1 = [[1, 0, 0, 0],
              [0, 1, 0, -350],
              [0, 0, 1, 0],
              [0, 0, 0, 1]];

   var t2 = [[1, 0, 0, 0],
              [0, 1, 0, 350],
              [0, 0, 1, 0],
              [0, 0, 0, 1]];

   // Transformation Matrix
   var Mtransform = MrotationY;
   var McameraTransform = Midentity;

   var m = [];

   m = MatrixMultiply3D(t1, Midentity);
   m = MatrixMultiply3D(MrotationY, m)
   m = MatrixMultiply3D(t2, m);
   //TODO: The top half is going in circles. Not what we want, but we're closer.
   
   var transformedPoints = [];
   for (var i=0; i<originalPoints.length; i++) {
    if (i <= 56) {
      transformedPoints[i] = VectorMultiply3D(m, originalPoints[i]);
    }
    else {
      transformedPoints[i] = originalPoints[i];
     }
   }


   // View-plane normal vector, N, is P0 - Pref
   var p0 = [0.0, -100.0, 500.0, 1.0];
   p0 = VectorMultiply3D(McameraTransform, p0);
   var pref = [0.0, 0.0, 0.0, 1.0];

   var pview = [100.0, 100.0, -400.0, 1.0];
   var prp = [100.0, 100.0, 400.0, 1.0];
   var zvp = -400;

   var Mwcvc = getWorldToViewingMatrix3D(p0, pref);

   // Parallel Projection
   var p1 = VectorMultiply3D(Mwcvc, p0);
   var p2 = VectorMultiply3D(Mwcvc, pview);
   var VP = [];
   for (var i=0; i<4; i++)
   {
     VP[i] = p2[i] - p1[i];
   }
   var Mparallel = getParallelProjectionMatrix(VP, zvp);

   // Perspective Projection
   Mperspective = getPerspectiveProjectionMatrix(prp, zvp);

   if (useParallelProjection)
   {
     var Mproject = MatrixMultiply3D(Mparallel, Mwcvc);
   }
   else
   {
     var Mproject = MatrixMultiply3D(Mperspective, Mwcvc);
   }

   // Combine projection and transformation matrix
   var Mfinal = MatrixMultiply3D(Mproject, Mtransform);

   //TODO: Use this as a baseline for how we do the transformations; just remember we only want the transformations happening
   //To certain shapes
   var projectedPoints = [];
   for (var i=0; i<originalPoints.length; i++)
   {
     projectedPoints[i] = VectorMultiply3D(Mfinal, transformedPoints[i]);
   }

   // Sort faces according to depth
   var depth = [];
   var faceOrder = [];
   for (var i=0; i<faces.length; i++)
   {
     var pt1 = projectedPoints[faces[i][0]];
     var pt2 = projectedPoints[faces[i][1]];
     var pt3 = projectedPoints[faces[i][2]];
     var pt4 = projectedPoints[faces[i][3]];

     depth[i] = Math.min(pt1[2], pt2[2], pt3[2], pt4[2]);
     faceOrder[i] = i;
   }
   for (var i=faces.length-1; i>0; i--)
   {
     for (var j=0; j<i; j++)
     {
       if (depth[j] > depth[j+1])
       {
         var t = depth[j];
         depth[j] = depth[j+1];
         depth[j+1] = t;
         t = faceOrder[j];
         faceOrder[j] = faceOrder[j+1];
         faceOrder[j+1] = t;
       }
     }
   }

   gl.clear(gl.COLOR_BUFFER_BIT);
   for (var i=0; i<faces.length; i++)
   {
     var x = faceOrder[i];
     var pt1 = projectedPoints[faces[x][0]];
     var pt2 = projectedPoints[faces[x][1]];
     var pt3 = projectedPoints[faces[x][2]];
     var pt4 = projectedPoints[faces[x][3]];

     // Display face (if it is visible)
     if (!solid || visibleFace(pt1, pt2, pt3, pt4))
     {
       var vertices = [];
       vertices = [ 0.001*pt1[0]/pt1[3], 0.001*pt1[1]/pt1[3],
                    0.001*pt2[0]/pt2[3], 0.001*pt2[1]/pt2[3],
                    0.001*pt3[0]/pt3[3], 0.001*pt3[1]/pt3[3],
                    0.001*pt4[0]/pt4[3], 0.001*pt4[1]/pt4[3] ];

       // Draw blank face
       gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
       gl.uniform4f(colorUniformLocation, 1.0, 1.0, 1.0, 1.0);
       gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length/2);

       // Draw outline of face
       var vertices = [];
       vertices = vertices.concat( drawLine(1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 2) );
       for (var z=0; z<vertices.length; z++)
       {
         vertices[z] /= 1000.0;
       }

       gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
       gl.uniform4f(colorUniformLocation, 0.0, 0.0, 1.0, 1.0);
       gl.drawArrays(gl.POINTS, 0, vertices.length/2);
     }
   }

   requestAnimFrame(render);
}



function init() {
   canvas = document.getElementById("gl-canvas");
   gl = WebGLUtils.setupWebGL(canvas);
   if (!gl) {
      alert("WebGL isn't available");
   }

   var program = initShaders(gl, "vertex-shader", "fragment-shader");

   var vPos = gl.getAttribLocation(program, "vPos");
   colorUniformLocation = gl.getUniformLocation(program, "u_color");
   var buffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

   gl.viewport(0, 0, canvas.width, canvas.height);
   gl.clearColor(0.9, 0.9, 0.9, 1.0);
   gl.clear(gl.COLOR_BUFFER_BIT);

   gl.useProgram(program);
   gl.enableVertexAttribArray(vPos);
   gl.vertexAttribPointer(vPos, 2, gl.FLOAT, false, 0, 0);

   render();
}


</script>

<body>
<canvas id="gl-canvas" width="500" height="500">
   Oops... your browser doesn't support HTML5's Canvas elements!
</canvas>
</body>
</html>