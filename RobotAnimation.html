<html>
<style type="text/css">
  canvas { background: red; }
</style>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec4 vPos;

void main()
{
  gl_PointSize = 1.0;
  gl_Position = vPos;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 u_color;

void main()
{
   gl_FragColor = u_color;
}
</script>


<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="initshaders.js"></script>
<script type="text/javascript" src="T7lines.js"></script>
<script type="text/javascript" src="T7matrices.js"></script>

<script>
window.addEventListener("keydown", keycheck, false);

function keycheck(e) {
  // Toggle pause/unpause when the letter p is pressed
  if (e.keyCode == "80") {
    paused = !paused;
  }

  // Toggle solid/opaque when the letter s is pressed
  if (e.keyCode == "83") {
    solid = !solid;
  }
}

</script>

<script type="text/javascript">
var canvas;
var gl;
var colorUniformLocation;
var offset = 0;
var degrees = 0;
var paused = false;
var solid = false;

var numPoints = 56;
var numFaces = 42;

// 3D World coordinate points
//TODO: Build a face on the robot... That'll be difficult, probably
//NOTE: for each cube you add here, adjust numPoints, numFaces, and faces variables.
var originalPoints = [  //Points for a cube that represents the robot's head
                        //Each cube should follow this same order, just to keep things simple.
                        [-150.0, -150.0, 250.0, 1.0], //bottom left, furthest away
                        [150.0, -150.0, 250.0, 1.0], //Bottom right, furthest away
                        [-150.0, 150.0, 250.0, 1.0], //Top left, furthest away
                        [150.0, 150.0, 250.0, 1.0], //Top right, furthest away
                        [-150.0, -150.0, -50.0, 1.0], //Bottom left closest
                        [150.0, -150.0, -50.0, 1.0], //Bottom right closest
                        [-150.0, 150.0, -50.0, 1.0], //Top left closest
                        [150.0, 150.0, -50.0, 1.0], //Top right closest

                        //Points for a rectangular prism that represents the robot's torso
                        [-100.0, -350.0, 200.0, 1.0],
                        [100.0, -350.0, 200.0, 1.0],
                        [-100.0, -150.0, 200.0, 1.0],
                        [100.0, -150.0, 200.0, 1.0],
                        [-100.0, -350.0, -25.0, 1.0],
                        [100.0, -350.0, -25.0, 1.0],
                        [-100.0,-150.0, -25.0, 1.0],
                        [100.0, -150.0, -25.0, 1.0],
                      
                        //Points for a rectangular prism that represents the robot's left arm
                        [-200.0, -350.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [-200.0, -150.0, 150.0, 1.0],
                        [-100.0, -150.0, 150.0, 1.0],
                        [-200.0, -350.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [-200.0, -150.0, 25.0, 1.0],
                        [-100.0, -150.0, 25.0, 1.0],  
                      
                        //Points for a rectangular prism that represents the robot's right arm
                        [100.0, -350.0, 150.0, 1.0],
                        [200.0, -350.0, 150.0, 1.0],
                        [100.0, -150.0, 150.0, 1.0],
                        [200.0, -150.0, 150.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0],
                        [200.0, -350.0, 25.0, 1.0],
                        [100.0, -150.0, 25.0, 1.0],
                        [200.0, -150.0, 25.0, 1.0], 
                      
                        //Points for a rectangular prism that represents the robot's left leg
                        [-100.0, -500.0, 150.0, 1.0],
                        [0.0, -500.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [-100.0, -500.0, 25.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0],

                        //Points for a rectangular prism that represents the robot's left leg
                        [0.0, -500.0, 150.0, 1.0],
                        [100.0, -500.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [100.0, -350.0, 150.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [100.0, -500.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0],
                        
                        //Points for a cube that represents the box the robot will pick up
                        [-100.0, -500.0, -50.0, 1.0],
                        [100.0, -500.0, -50.0, 1.0],
                        [-100.0, -350.0, -50.0, 1.0],
                        [100.0, -350.0, -50.0, 1.0],
                        [-100.0, -500.0, -150.0, 1.0],
                        [100.0, -500.0, -150.0, 1.0],
                        [-100.0,-350.0, -150.0, 1.0],
                        [100.0, -350.0, -150.0, 1.0] ];

//We just need the one faces vector since we're only doing cubes
var faces = [ //0-7
              [0, 1, 3, 2],
              [5, 4, 6, 7],
              [4, 0, 2, 6],
              [1, 5, 7, 3],
              [2, 3, 7, 6],
              [1, 0, 4, 5],

              //8-15
              [8, 9, 11, 10],
              [13, 12, 14, 15],
              [12, 8, 10, 14],
              [9, 13, 15, 11],
              [10, 11, 15, 14],
              [9, 8, 12, 13],

              //16-23
              [16, 17, 19, 18],
              [21, 20, 22, 23],
              [20, 16, 18, 22],
              [17, 21, 23, 19],
              [18, 19, 23, 22],
              [17, 16, 20, 21],
            
              //24-31
              [24, 25, 27, 26],
              [29, 28, 30, 31],
              [28, 24, 26, 30],
              [25, 29, 31, 27],
              [26, 27, 31, 30],
              [25, 24, 28, 29],
              
              //32-39
              [32, 33, 35, 34],
              [37, 36, 38, 39],
              [36, 32, 34, 38],
              [33, 37, 39, 35],
              [34, 35, 39, 38],
              [33, 32, 36, 37],
            
              //40-47
              [40, 41, 43, 42],
              [45, 44, 46, 47],
              [44, 40, 42, 46],
              [41, 45, 47, 43],
              [42, 43, 47, 46],
              [41, 40, 44, 45],

              //48-55
              [48, 49, 51, 50],
              [53, 52, 54, 55],
              [52, 48, 50, 54],
              [49, 53, 55, 51],
              [50, 51, 55, 54],
              [49, 48, 52, 53]  ];

window.onload = init;

function render()
{
   if (!paused)
   {
     offset+=2;
     degrees+=2;
   }
   if (offset > 500)
   {
     offset = 0;
   }
   if (degrees > 360)
   {
     degrees = 0;
   }
   var radians = degrees * (Math.PI / 180.0);


   // Transformation Matrix
   var Mtransform = RotationYMatrix3D(degrees);
   var McameraTransform = IdentityMatrix3D();

   // View-plane normal vector, N, is P0 - Pref
   var p0 = [0.0, -100.0, 500.0, 1.0];
   p0 = VectorMultiply3D(McameraTransform, p0);
   var pref = [0.0, 0.0, 0.0, 1.0];

   var pview = [100.0, 100.0, -400.0, 1.0];    //View point (where the camera is); Idk if z point changes anything though
   var zvp = -400;

   var Mwcvc = getWorldToViewingMatrix3D(p0, pref);
   var Mparallel = getParallelProjectionMatrix(pview, zvp);
   var Mproject = MatrixMultiply3D(Mparallel, Mwcvc);
   var Mfinal = MatrixMultiply3D(Mproject, Mtransform);

   var projectedPoints = [];
   for (var i=0; i<numPoints; i++)
   {
     projectedPoints[i] = VectorMultiply3D(Mfinal, originalPoints[i]);
     for (var j=0; j<=3; j++)
     {
       if (projectedPoints[i][3] != 0)
       {
         projectedPoints[i][j] /= (1.0*projectedPoints[i][3]);
       }
     }
   }
   
   vertices = [];
   for (var i=0; i<numFaces; i++)
   {
     var pt1 = projectedPoints[faces[i][0]];
     var pt2 = projectedPoints[faces[i][1]];
     var pt3 = projectedPoints[faces[i][2]];
     var pt4 = projectedPoints[faces[i][3]];

     // Display face (if it is visible)
     if (!solid || visibleFace(pt1, pt2, pt3, pt4))
     /*TODO: We're going to have to add to this logic or change visible face.
    Likely the new logic would look like:
    if (!solid || (visibleFace(pt1, pt2, pt3, pt4) && zValue>lastShapeZVal) {
      write code here
    }
      
    BUT that won't work because this for statement is for the faces. Hm. Maybe write another statement since we need to go point by point*/
     {      
       vertices = vertices.concat( drawLine(1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 2) );
       vertices = vertices.concat( drawLine(1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 2) );
     }
   }

   for (var i=0; i<vertices.length; i++)
   {
     vertices[i] = vertices[i]/1000.0;
   }

   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
   gl.clear(gl.COLOR_BUFFER_BIT);
   gl.uniform4f(colorUniformLocation, 0.0, 0.0, 1.0, 1.0);
   gl.drawArrays(gl.POINTS, 0, vertices.length/2);

   requestAnimFrame(render);
}



function init() {
   canvas = document.getElementById("gl-canvas");
   gl = WebGLUtils.setupWebGL(canvas);
   if (!gl) {
      alert("WebGL isn't available");
   }

   var program = initShaders(gl, "vertex-shader", "fragment-shader");

   var vPos = gl.getAttribLocation(program, "vPos");
   colorUniformLocation = gl.getUniformLocation(program, "u_color");
   var buffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

   gl.viewport(0, 0, canvas.width, canvas.height);
   gl.clearColor(0.9, 0.9, 0.9, 1.0);
   gl.clear(gl.COLOR_BUFFER_BIT);

   gl.useProgram(program);
   gl.enableVertexAttribArray(vPos);
   gl.vertexAttribPointer(vPos, 2, gl.FLOAT, false, 0, 0);

   render();
}


</script>

<body>
<canvas id="gl-canvas" width="500" height="500">
   Oops... your browser doesn't support HTML5's Canvas elements!
</canvas>
</body>
</html>