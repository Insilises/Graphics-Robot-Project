<html>
<style type="text/css">
  canvas { background: red; }
</style>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec4 vPos;

void main()
{
  gl_PointSize = 1.0;
  gl_Position = vPos;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 u_color;

void main()
{
   gl_FragColor = u_color;
}
</script>


<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="initshaders.js"></script>
<script type="text/javascript" src="T7lines.js"></script>
<script type="text/javascript" src="T7matrices.js"></script>

<script>
window.addEventListener("keydown", keycheck, false);

function keycheck(e) {
  // Toggle pause/unpause when the letter p is pressed
  if (e.keyCode == "80") {
    paused = !paused;
  }

  // Toggle solid/opaque when the letter s is pressed
  if (e.keyCode == "83") {
    solid = !solid;
  }
}

</script>

<script type="text/javascript">
var canvas;
var gl;
var colorUniformLocation;
var offset = 0;
var degrees = 0;
var paused = false;
var solid = false;

//If I have everything as prisms in their own, separate matrix, this could change. We could use a constant set of numbers.
var numPoints = 8;
var numFaces = 6;

// 3D World coordinate points
//TODO: Build a face on the robot... That'll be difficult, probably
//NOTE: for each cube you add here, adjust numPoints, numFaces, and faces variables.
/*Represents the robot's torso, head and face. The animation should have these parts move the same as the robot bends over*/
var roboHead = [  //Points for a cube that represents the robot's head
                        //Each cube should follow this same order, just to keep things simple.
                        [-150.0, -150.0, 250.0, 1.0], //bottom left, furthest away
                        [150.0, -150.0, 250.0, 1.0], //Bottom right, furthest away
                        [-150.0, 150.0, 250.0, 1.0], //Top left, furthest away
                        [150.0, 150.0, 250.0, 1.0], //Top right, furthest away
                        [-150.0, -150.0, -50.0, 1.0], //Bottom left closest
                        [150.0, -150.0, -50.0, 1.0], //Bottom right closest
                        [-150.0, 150.0, -50.0, 1.0], //Top left closest
                        [150.0, 150.0, -50.0, 1.0]  ]; //Top right closest

var roboMouth = [//Points for a prism that represents the robot's mouth
                        /*Copy pasted from head; Maybe we don't need the back face since it'll never be drawn *shrugs*
                        TODO: Work this out bc... Huh? Maybe we do need all of these points. Otherwise, things get confusing.
                        We can still divide these into their own matrices since each of these will do different things in the animation
                        */
                       
                        [-50.0, -100.0, -50.0, 1.0],
                        [50.0, -100.0, -50.0, 1.0],
                        [-50.0, -50.0, -50.0, 1.0], 
                        [50.0, -50.0, -50.0, 1.0],
                        [-50.0, -100.0, -51.0, 1.0],
                        [50.0, -100.0, -51.0, 1.0],
                        [-50.0, -50.0, -51.0, 1.0],
                        [50.0, -50.0, -51.0, 1.0] ];

var roboLeftEye = [//Points for a prism that represents the robot's left eye
                        [-50.0, -0.0, -50.0, 1.0],
                        [0.0, -0.0, -50.0, 1.0],
                        [-50.0, 50.0, -50.0, 1.0], 
                        [0.0, 50.0, -50.0, 1.0],
                        [-50.0, 0.0, -51.0, 1.0],
                        [0.0, 0.0, -51.0, 1.0],
                        [-50.0, 50.0, -51.0, 1.0],
                        [0.0, 50.0, -51.0, 1.0] ];

var roboRightEye = [//Points for a prism that represents the robot's right eye
                        [75.0, 0.0, -50.0, 1.0],
                        [25.0, 0.0, -50.0, 1.0],
                        [75.0, 50.0, -50.0, 1.0], 
                        [25.0, 50.0, -50.0, 1.0],
                        [75.0, 0.0, -51.0, 1.0],
                        [25.0, 0.0, -51.0, 1.0],
                        [75.0, 50.0, -51.0, 1.0],
                        [25.0, 50.0, -51.0, 1.0] ];

var roboTorso = [//Points for a rectangular prism that represents the robot's torso
                        [-100.0, -350.0, 200.0, 1.0],
                        [100.0, -350.0, 200.0, 1.0],
                        [-100.0, -150.0, 200.0, 1.0],
                        [100.0, -150.0, 200.0, 1.0],
                        [-100.0, -350.0, -25.0, 1.0],
                        [100.0, -350.0, -25.0, 1.0],
                        [-100.0,-150.0, -25.0, 1.0],
                        [100.0, -150.0, -25.0, 1.0]  ];

//The robot's arms will move the same as each other, lowering as it picks up the box.
var roboLeftArm = [        //Points for a rectangular prism that represents the robot's left arm
                        [-200.0, -350.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [-200.0, -150.0, 150.0, 1.0],
                        [-100.0, -150.0, 150.0, 1.0],
                        [-200.0, -350.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [-200.0, -150.0, 25.0, 1.0],
                        [-100.0, -150.0, 25.0, 1.0] ];

var roboRightArm = [//Points for a rectangular prism that represents the robot's right arm
                        [100.0, -350.0, 150.0, 1.0],
                        [200.0, -350.0, 150.0, 1.0],
                        [100.0, -150.0, 150.0, 1.0],
                        [200.0, -150.0, 150.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0],
                        [200.0, -350.0, 25.0, 1.0],
                        [100.0, -150.0, 25.0, 1.0],
                        [200.0, -150.0, 25.0, 1.0]  ];
//The robot's legs won't move at all.
var roboLeftLeg = [
                        //Points for a rectangular prism that represents the robot's left leg
                        [-100.0, -500.0, 150.0, 1.0],
                        [0.0, -500.0, 150.0, 1.0],
                        [-100.0, -350.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [-100.0, -500.0, 25.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [-100.0, -350.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0] ];

var roboRightLeg = [//Points for a rectangular prism that represents the robot's left leg
                        [0.0, -500.0, 150.0, 1.0],
                        [100.0, -500.0, 150.0, 1.0],
                        [0.0, -350.0, 150.0, 1.0],
                        [100.0, -350.0, 150.0, 1.0],
                        [0.0, -500.0, 25.0, 1.0],
                        [100.0, -500.0, 25.0, 1.0],
                        [0.0, -350.0, 25.0, 1.0],
                        [100.0, -350.0, 25.0, 1.0]  ];
                        
var boxPoints = [//Points for a cube that represents the box the robot will pick up
                        [-100.0, -500.0, -50.0, 1.0],
                        [100.0, -500.0, -50.0, 1.0],
                        [-100.0, -350.0, -50.0, 1.0],
                        [100.0, -350.0, -50.0, 1.0],
                        [-100.0, -500.0, -150.0, 1.0],
                        [100.0, -500.0, -150.0, 1.0],
                        [-100.0,-350.0, -150.0, 1.0],
                        [100.0, -350.0, -150.0, 1.0]  ];

//We just need the one faces vector since we're only doing cubes and prisms. Each vector doesn't have more than 5 objects, so this is all we have to worry about.
var faces = [  //0-7
              [0, 1, 3, 2],
              [5, 4, 6, 7],
              [4, 0, 2, 6],
              [1, 5, 7, 3],
              [2, 3, 7, 6],
              [1, 0, 4, 5]];

var zBuffer = [];

window.onload = init;

function render()
{
  
   if (!paused)
   {
     offset+=2;
     degrees+=2;
   }
   if (offset > 500)
   {
     offset = 0;
   }
   if (degrees > 360)
   {
     degrees = 0;
   }
   var radians = degrees * (Math.PI / 180.0);
   
  

   /*The way to do the animations would be to have some kind of boolean that would be set true when the button is pressed
   but this value would be set false when the animation is over (perhaps when the box is in a certain spot?)*/

   // Transformation Matrix for camera
   var Mtransform = RotationYMatrix3D(degrees);
   var McameraTransform = IdentityMatrix3D();

   //TODO: Do transformations of matrices here.

   // View-plane normal vector, N, is P0 - Pref
   var p0 = [0.0, -100.0, 500.0, 1.0];
   p0 = VectorMultiply3D(McameraTransform, p0);
   var pref = [0.0, 0.0, 0.0, 1.0];

   var pview = [100.0, 100.0, -400.0, 1.0];    //View point (where the camera is); Idk if z point changes anything though
   var zvp = -400.0;

   var Mwcvc = getWorldToViewingMatrix3D(p0, pref);
   var Mparallel = getParallelProjectionMatrix(pview, zvp);
   var Mproject = MatrixMultiply3D(Mparallel, Mwcvc);
   var Mfinal = MatrixMultiply3D(Mproject, Mtransform);

   currentCameraZ = Mwcvc[2];
   
   //Initialize all values (for each X,Y position) to camera position and to white.
  for (i=0; i<1000; i++) { //For every X value
    for (j=0; j<1000; j++) { //For every Y value
      zBuffer[i][j] = [zvp, 1.0, 1.0, 1.0, 1.0];
    }
  }

   var projectedHeadPoints = [];
   for (var i=0; i<numPoints; i++) {
    projectedHeadPoints[i] = VectorMultiply3D(Mfinal, roboHead[i]);
     for (var j=0; j<=3; j++) {
       if (projectedHeadPoints[i][3] != 0) {
        projectedHeadPoints[i][j] /= (1.0*projectedHeadPoints[i][3]);
       }
     }
   }
   
   vertices = [];

   for (var i=0; i<numFaces; i++) {
      var pt1 = projectedHeadPoints[faces[i][0]];
      var pt2 = projectedHeadPoints[faces[i][1]];
      var pt3 = projectedHeadPoints[faces[i][2]];
      var pt4 = projectedHeadPoints[faces[i][3]];

      // Display face (if it is visible)
      if (!solid || visibleFace(pt1, pt2, pt3, pt4)) {
        vertices = vertices.concat( drawLine(1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 2) );
        vertices = vertices.concat( drawLine(1.0*pt2[0]/pt2[3], 1.0*pt2[1]/pt2[3], 1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 2) );
        vertices = vertices.concat( drawLine(1.0*pt3[0]/pt3[3], 1.0*pt3[1]/pt3[3], 1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 2) );
        vertices = vertices.concat( drawLine(1.0*pt4[0]/pt4[3], 1.0*pt4[1]/pt4[3], 1.0*pt1[0]/pt1[3], 1.0*pt1[1]/pt1[3], 2) );
     }
   }
   //TODO: Add all other vectors to vertices. Remember, they're all separate due to the animations.
   
   
   //Once Vertices is populated with the actual lines, we can use triangle fan to draw using the points we have. We don't
   //have to worry about fill algorithms.

   

   for (var i=0; i<vertices.length; i++)
   {
     vertices[i] = vertices[i]/1000.0;
   }

   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
   gl.clear(gl.COLOR_BUFFER_BIT);
   gl.uniform4f(colorUniformLocation, 0.0, 0.0, 1.0, 1.0);
   gl.drawArrays(gl.POINTS, 0, vertices.length/2);

   requestAnimFrame(render);
}



function init() {
   canvas = document.getElementById("gl-canvas");
   gl = WebGLUtils.setupWebGL(canvas);
   if (!gl) {
      alert("WebGL isn't available");
   }

   var program = initShaders(gl, "vertex-shader", "fragment-shader");

   var vPos = gl.getAttribLocation(program, "vPos");
   colorUniformLocation = gl.getUniformLocation(program, "u_color");
   var buffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

   gl.viewport(0, 0, canvas.width, canvas.height);
   gl.clearColor(0.9, 0.9, 0.9, 1.0);
   gl.clear(gl.COLOR_BUFFER_BIT);

   gl.useProgram(program);
   gl.enableVertexAttribArray(vPos);
   gl.vertexAttribPointer(vPos, 2, gl.FLOAT, false, 0, 0);

   render();
}


</script>

<body>
<canvas id="gl-canvas" width="500" height="500">
   Oops... your browser doesn't support HTML5's Canvas elements!
</canvas>
</body>
</html>